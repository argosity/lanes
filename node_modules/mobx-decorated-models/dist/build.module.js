import { createModelSchema, deserialize, getDefaultModelSchema, identifier, list, object, primitive, serialize, update } from 'serializr';
import { intercept, observable } from 'mobx';

var ModelsMap = new Map();

function defaultModelLookup(_ref) {
    var property = _ref.property,
        _ref$model = _ref.model,
        model = _ref$model === undefined ? property : _ref$model;

    if (typeof model === 'function') {
        return model;
    }
    return ModelsMap[model] || ModelsMap[property];
}
var modelLookup = defaultModelLookup;

var defaultRememberModel = function defaultRememberModel(model) {
    ModelsMap[model.identifiedBy || model.name] = model;
};
var rememberModel = defaultRememberModel;

function registerModel(model) {
    rememberModel(model);
}

function findModel(model, property) {
    return modelLookup({ model: model, property: property });
}

function rememberModelUsing(fn) {
    rememberModel = fn || defaultRememberModel;
}

function lookupModelUsing(fn) {
    modelLookup = fn || defaultModelLookup;
}

function isSerializable(model, property) {
    return !!(!model.$nonSerializable || !model.$nonSerializable[property]);
}

function markNonserializable(model, property) {
    model.$nonSerializable = model.$nonSerializable || {};
    model.$nonSerializable[property] = true;
}

var getModelSchema = function (model) {
    if (model.$schema) {
        return model.$schema;
    }
    var schema = observable.shallowMap();
    Object.defineProperty(model, '$schema', {
        enumerable: false,
        writable: false,
        configurable: true,
        value: schema
    });
    return schema;
};

var PendingLookups = [];

function objectSerializer() {
    return {
        serializer: function serializer(obj, prop, parent) {
            return isSerializable(parent, prop) ? obj : undefined;
        },
        deserializer: function deserializer(json, cb) {
            cb(null, json);
        }
    };
}

function addReference(parentModel, propName, options, cb) {
    var model = findModel(options.model, propName);
    if (model) {
        getDefaultModelSchema(parentModel).props[propName] = cb(model, options, propName);
    } else {
        getDefaultModelSchema(parentModel).props[propName] = objectSerializer();
        PendingLookups.push({ parentModel: parentModel, propName: propName, options: options, cb: cb });
    }
}

function getSerializer(options, defaultSerializer) {
    var serializer = void 0;
    if (options.type === 'object') {
        serializer = objectSerializer;
    } else if (options.type === 'array') {
        serializer = list;
    } else {
        serializer = defaultSerializer;
    }
    var fns = serializer();
    if (options.writeOnly) {
        return {
            serializer: function serializer() {
                return undefined;
            },
            deserializer: fns.deserializer
        };
    }
    return fns;
}

var Fields = {
    identifier: function identifier$$1(options) {
        return getSerializer(options, identifier);
    },
    field: function field(options) {
        return getSerializer(options, primitive);
    },
    session: function session(options) {
        return getSerializer(Object.assign({}, options, { writeOnly: true }), primitive);
    }
};

var Associations = {
    hasMany: function hasMany(modelKlass, options) {
        var defaultSerializer = list(object(modelKlass));
        return Object.assign(defaultSerializer, options, {
            model: modelKlass
        });
    },
    belongsTo: function belongsTo(modelKlass, options, propName) {
        var defaultSerializer = object(getDefaultModelSchema(modelKlass));
        return Object.assign(options, {
            model: modelKlass,
            deserializer: function deserializer(value, cb, context) {
                defaultSerializer.deserializer(value, function (err, model) {
                    if (!err && options.inverseOf) {
                        markNonserializable(model, options.inverseOf);
                        model[options.inverseOf + '_association_name'] = propName;
                        model[options.inverseOf] = context.target;
                    }
                    cb(err, model);
                });
            },
            serializer: function serializer(belongsTo, name, parent) {
                if (!isSerializable(parent, name)) {
                    return undefined;
                }
                return defaultSerializer.serializer(belongsTo);
            }
        });
    }
};

var MixedInInstanceMethods = {
    serialize: function serialize$$1() {
        var schema = getDefaultModelSchema(this.constructor);
        return serialize(schema, this);
    },
    update: function update$$1(json, callback) {
        return update(getDefaultModelSchema(this.constructor), this, json, callback);
    }
};

var MixedInClassMethods = {
    deserialize: function deserialize$$1(json, callback) {
        return deserialize(getDefaultModelSchema(this), json, callback);
    }
};

function decorateModel(model) {
    Object.assign(model.prototype, MixedInInstanceMethods);
    Object.assign(model, MixedInClassMethods);

    var schema = getModelSchema(model);
    registerModel(model);
    var serializeSchema = {};
    schema.forEach(function (_ref, name) {
        var type = _ref.type,
            options = _ref.options;

        if (Fields[type]) {
            serializeSchema[name] = Fields[type](options, name);
        }
    });
    createModelSchema(model, serializeSchema);
    schema.forEach(function (_ref2, name) {
        var type = _ref2.type,
            options = _ref2.options;

        if (Associations[type]) {
            addReference(model, name, options, Associations[type]);
        }
    });
    for (var i = PendingLookups.length - 1; i >= 0; i -= 1) {
        var _PendingLookups$i = PendingLookups[i],
            parentModel = _PendingLookups$i.parentModel,
            propName = _PendingLookups$i.propName,
            options = _PendingLookups$i.options,
            cb = _PendingLookups$i.cb;

        var referencedModel = findModel(options.model, propName);
        if (referencedModel) {
            var parentModelSchema = getDefaultModelSchema(parentModel);
            parentModelSchema.props[propName] = cb(referencedModel, options, propName);
            PendingLookups.splice(i, 1);
        }
    }
}

function modelDecorator(modelOrIdentifier) {
    if (typeof modelOrIdentifier === 'function') {
        modelOrIdentifier.identifiedBy = modelOrIdentifier.name;
        return decorateModel(modelOrIdentifier);
    }
    return function (model) {
        model.identifiedBy = modelOrIdentifier;
        return decorateModel(model);
    };
}

function unresolvedAssociations() {
    return PendingLookups.map(function (_ref3) {
        var model = _ref3.parentModel,
            property = _ref3.propName;
        return { model: model, property: property };
    });
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};























































var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

function addLazyInitializer(target, fn) {
    target.__mobxLazyInitializers.push(fn);
}

function setupModel(_ref) {
    var attrs = _ref.attrs,
        Klass = _ref.modelClass,
        array = _ref.array,
        defaultAttributes = _ref.defaultAttributes,
        inverseOf = _ref.inverseOf,
        parentModel = _ref.parentModel,
        parentModelProp = _ref.parentModelProp;

    if (!attrs || (typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs)) !== 'object') {
        return attrs;
    }
    if (defaultAttributes) {
        if (typeof defaultAttributes === 'function') {
            defaultAttributes = defaultAttributes.call(parentModel, array, parentModel);
        }
        Object.keys(defaultAttributes).forEach(function (key) {
            if (!attrs[key]) {
                attrs[key] = defaultAttributes[key];
            }
        });
    }
    if (inverseOf) {
        if (parentModelProp) {
            attrs[inverseOf + '_association_name'] = parentModelProp;
        }
        attrs[inverseOf] = parentModel;
    }
    var model = Klass && !(attrs instanceof Klass) ? new Klass(attrs) : attrs;
    if (inverseOf) {
        markNonserializable(model, inverseOf);
    }
    return model;
}

function onBelongsToSet(change, _ref2) {
    var modelClass = _ref2.modelClass,
        defaultAttributes = _ref2.defaultAttributes,
        inverseOf = _ref2.inverseOf,
        parentModel = _ref2.parentModel,
        parentModelProp = _ref2.parentModelProp;

    change.newValue = setupModel({
        attrs: change.newValue, modelClass: modelClass,
        defaultAttributes: defaultAttributes, inverseOf: inverseOf, parentModel: parentModel, parentModelProp: parentModelProp
    });
    return change;
}

function onHasManySet(change, _ref3) {
    var modelClass = _ref3.modelClass,
        defaultAttributes = _ref3.defaultAttributes,
        inverseOf = _ref3.inverseOf,
        parentModel = _ref3.parentModel,
        parentModelProp = _ref3.parentModelProp;

    if (change.type !== 'update' || !change.newValue) {
        return change;
    }
    var array = change.newValue;


    for (var i = 0; i < array.length; i += 1) {
        array[i] = setupModel({
            attrs: array[i], array: array, modelClass: modelClass,
            defaultAttributes: defaultAttributes, inverseOf: inverseOf, parentModel: parentModel, parentModelProp: parentModelProp
        });
    }

    if (parentModel[parentModelProp]) {
        parentModel[parentModelProp].replace(array);
        return null;
    } else {
        change.newValue = observable.array(array);
        return change;
    }
}

function onCollectionChangeInterceptor(_ref4, parentModel, parentModelProp) {
    var modelClass = _ref4.modelClass,
        model = _ref4.model,
        defaultAttributes = _ref4.defaults,
        inverseOf = _ref4.inverseOf;

    return function (change) {
        if (!change.newValue) {
            change.newValue = {};
        }
        if (!modelClass) {
            modelClass = findModel(model, parentModelProp);
        }
        if (change.type === 'splice') {
            for (var i = 0; i < change.added.length; i += 1) {
                change.added[i] = setupModel({
                    attrs: change.added[i], array: change.object, modelClass: modelClass,
                    defaultAttributes: defaultAttributes, inverseOf: inverseOf, parentModel: parentModel, parentModelProp: parentModelProp });
            }
        } else if (change.type === 'update') {
            change.newValue = setupModel({
                attrs: change.newValue, array: change.object, modelClass: modelClass,
                defaultAttributes: defaultAttributes, inverseOf: inverseOf, parentModel: parentModel, parentModelProp: parentModelProp });
        }
        return change;
    };
}

function buildCollection(options, parentModel, parentModelProp) {
    var ary = observable.array([]);
    if (options.classId || options.model) {
        ary.intercept(onCollectionChangeInterceptor(options, parentModel, parentModelProp));
    }
    return ary;
}

var Initializers = {
    object: function object$$1() {
        return observable.object({});
    },
    array: buildCollection
};

var TypeInitializers = {
    hasMany: buildCollection
};

function getInitializer(type, options, propName) {
    var fn = TypeInitializers[type] || Initializers[options.type];
    if (!fn) {
        return undefined;
    }
    return function () {
        // eslint-disable-line func-names
        return fn(options, this, propName);
    };
}

function addAttribute(type, target, property, descriptor) {
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

    getModelSchema(target.constructor).set(property, { name: property, type: type, options: options });
    var initializer = getInitializer(type, options, property);
    if (initializer) {
        descriptor.initializer = initializer;
    }
    var definition = observable(target, property, descriptor);
    return definition;
}

function buildAttributeDecorator(type, args) {
    var attributeAddFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : addAttribute;

    if (_typeof(args[0]) === 'object' && args.length === 1) {
        return function (target, property, descriptor) {
            return attributeAddFn(type, target, property, descriptor, args[0]);
        };
    }
    return attributeAddFn.apply(undefined, [type].concat(toConsumableArray(args), [{}]));
}

function interceptingDecorator(interceptingFn) {
    return function (type, target, property, descriptor) {
        var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

        var decorator = addAttribute(type, target, property, descriptor, options);
        addLazyInitializer(target, function (model) {
            var schema = getDefaultModelSchema(target);
            if (schema && schema.props[property]) {
                (function () {
                    var schemaProps = schema.props[property];
                    intercept(model, property, function (change) {
                        return interceptingFn(change, {
                            inverseOf: schemaProps.inverseOf,
                            modelClass: schemaProps.model,
                            parentModel: model,
                            parentModelProp: property,
                            defaultAttributes: schemaProps.defaults
                        });
                    });
                })();
            }
        });
        return decorator;
    };
}

var hasMany = function hasMany() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
    }

    return buildAttributeDecorator('hasMany', args, interceptingDecorator(onHasManySet));
};

var belongsTo = function belongsTo() {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
    }

    return buildAttributeDecorator('belongsTo', args, interceptingDecorator(onBelongsToSet));
};

var identifier$1 = function identifier$$1() {
    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
    }

    return buildAttributeDecorator('identifier', args);
};
var field = function field() {
    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
    }

    return buildAttributeDecorator('field', args);
};
var session = function session() {
    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
    }

    return buildAttributeDecorator('session', args);
};

export { registerModel, findModel, rememberModelUsing, lookupModelUsing, modelDecorator, unresolvedAssociations, field, session, belongsTo, hasMany, identifier$1 as identifier, buildCollection };
//# sourceMappingURL=build.module.js.map
